<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RNG Biome Game Prototype (FULL - FIXED v4)</title>
  <style>
    :root{
      --ui: rgba(0,0,0,.55);
      --text: #f2f2f2;
      --muted:#cfcfcf;
      --border: rgba(255,255,255,.18);
      --border2: rgba(255,255,255,.28);

      /* biome colors */
      --c-normal: #90F09A;
      --c-windy: #ADEAF0;
      --c-rainy: #519DEE;
      --c-snowy: #ffffff;
      --c-quake: #E7A962;
      --c-undefined: #3a364a;
      --c-glitched: #850605;

      --whiteTint: .35;
    }

    *{ box-sizing:border-box; font-family: Arial, Helvetica, sans-serif; }
    body{
      margin:0;
      color:var(--text);
      background:#0b0b10;
      height:100vh;
      overflow:hidden;
      user-select:none;
    }

    /* ===== Background layers ===== */
    #bg{
      position:fixed; inset:0;
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,.10), transparent 45%),
        radial-gradient(circle at 70% 80%, rgba(255,255,255,.08), transparent 40%),
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.65));
      transform: translateZ(0);
    }
    #biomeColor{
      position:fixed; inset:0;
      background: var(--c-normal);
      opacity:.55;
      transition: background-color .45s ease, opacity .45s ease, filter .45s ease;
      mix-blend-mode: multiply;
      pointer-events:none;
    }
    #whiteOverlay{
      position:fixed; inset:0;
      background:#fff;
      opacity: var(--whiteTint);
      transition: opacity .45s ease;
      pointer-events:none;
    }

    /* ===== Glitched FX layers ===== */
    #glitchNoise, #glitchScanlines, #glitchSlices{
      position:fixed; inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity .2s ease;
    }
    #glitchScanlines{
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.08) 0px,
        rgba(255,255,255,.08) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 4px
      );
      mix-blend-mode: overlay;
    }
    #glitchSlices{ mix-blend-mode: screen; }

    /* ===== Top bar ===== */
    #topBar{
      position:fixed; top:10px; right:10px;
      background:var(--ui);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      min-width:320px;
      backdrop-filter: blur(6px);
      z-index:5;
    }
    #topBar .row{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
    #topBar .small{ font-size:12px; color:var(--muted); }
    #topBar .strong{ font-weight:700; }

    /* ===== Left bar ===== */
    #leftBar{
      position:fixed; left:10px; top:70px;
      display:flex; flex-direction:column; gap:8px;
      z-index:5;
    }
    .iconBtn{
      width:46px; height:46px;
      background:var(--ui);
      border:1px solid var(--border);
      border-radius:12px;
      display:grid; place-items:center;
      cursor:pointer;
      backdrop-filter: blur(6px);
      position:relative;
    }
    .iconBtn:hover{ border-color:var(--border2); }
    .iconBtn .tip{
      position:absolute;
      left:54px; top:50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,.75);
      border:1px solid rgba(255,255,255,.2);
      border-radius:10px;
      padding:6px 8px;
      font-size:12px;
      color:#fff;
      white-space:nowrap;
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease;
    }
    .iconBtn:hover .tip{ opacity:1; }

    /* ===== Bottom roll bar ===== */
    #bottomBar{
      position:fixed; left:0; right:0; bottom:0;
      padding:12px 14px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      z-index:5;
    }
    #rollPanel{
      margin:0 auto;
      width:min(720px, 96vw);
      background:var(--ui);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(6px);
    }
    #rollPanelTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--muted);
    }
    .toggle button{
      background: rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.22);
      color:#fff;
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      min-width:78px;
    }
    .toggle button.locked{
      opacity:.45;
      cursor:not-allowed;
    }
    #rollBtn{
      flex:1;
      margin:0 10px;
      background: rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.22);
      color:#fff;
      padding:10px 14px;
      border-radius:12px;
      font-size:16px;
      font-weight:900;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:.6px;
    }
    #rollBtn:active{ transform: scale(.99); }

    #rollPanelBottom{
      display:flex;
      justify-content:space-between;
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
    }

    /* ===== Buff bar ===== */
    #buffBar{
      display:flex;
      align-items:flex-end;
      gap:8px;
      padding:10px;
      background:var(--ui);
      border:1px solid var(--border);
      border-radius:14px;
      backdrop-filter: blur(6px);
      min-width:280px;
      justify-content:flex-end;
      overflow:hidden;
    }
    .buffIcon{
      width:42px; height:42px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      position:relative;
      display:grid; place-items:center;
      font-weight:900;
      cursor:pointer;
    }
    .buffIcon.inactive{ opacity:.35; cursor:default; }
    .buffIcon .t{
      position:absolute; bottom:2px; right:6px;
      font-size:11px;
      color:#fff;
      text-shadow: 0 1px 2px rgba(0,0,0,.8);
    }
    .buffIcon .x{
      position:absolute; top:2px; left:6px;
      font-size:11px;
      color:#fff;
      text-shadow: 0 1px 2px rgba(0,0,0,.8);
    }

    /* ===== Roll popups (Quick Roll ON) ===== */
    #popupLane{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:110px;
      width:min(720px, 96vw);
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      z-index:4;
    }
    .popup{
      width:100%;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.20);
      border-radius:14px;
      padding:12px 14px;
      backdrop-filter: blur(6px);
      display:flex;
      justify-content:space-between;
      align-items:center;
      opacity:0;
      transform: translateY(8px);
      animation: popIn .18s ease forwards;
    }
    @keyframes popIn{ to{ opacity:1; transform: translateY(0); } }
    .popup .name{ font-weight:900; font-size:18px; }
    .popup .rar{ font-size:12px; color:var(--muted); margin-top:4px; }
    .popup .right{ text-align:right; font-size:12px; color:var(--muted); }

    /* ===== Result panel (Quick Roll OFF) ===== */
    #resultBox{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:110px;
      width:min(520px, 92vw);
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.20);
      border-radius:14px;
      padding:12px 14px;
      backdrop-filter: blur(6px);
      display:none;
      z-index:4;
    }
    #resultBox .big{ font-weight:900; font-size:20px; }
    #resultBox .small{ margin-top:6px; font-size:12px; color:var(--muted); }

    /* ===== Modals ===== */
    .modal{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .modal .card{
      width:min(1100px, 98vw);
      height:min(680px, 92vh);
      background: rgba(0,0,0,.70);
      border:1px solid rgba(255,255,255,.22);
      border-radius:16px;
      backdrop-filter: blur(10px);
      display:flex;
      overflow:hidden;
      position:relative;
    }
    .modal .close{
      position:absolute;
      top:10px; right:10px;
      width:40px; height:40px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.10);
      color:#fff;
      font-size:18px;
      font-weight:900;
      cursor:pointer;
    }
    .modalHeader{
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      font-weight:900;
      font-size:24px;
      pointer-events:none;
    }

    /* Aura Storage */
    #auraModal .leftInfo{
      width:340px;
      padding:58px 14px 14px 14px;
      border-right:1px solid rgba(255,255,255,.14);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .infoBox{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:12px;
    }
    .infoTitle{ font-weight:900; font-size:18px; }
    .infoSub{ color:var(--muted); font-size:12px; margin-top:6px; }
    .infoStat{ color:var(--muted); font-size:12px; margin-top:8px; line-height:1.35; }

    .btnRow{ display:flex; gap:10px; margin-top:8px; }
    .btn{
      flex:1;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .btn.good{ border-color: rgba(86,211,100,.35); }
    .btn.bad{ border-color: rgba(255,77,77,.35); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }

    #auraModal .rightGrid{
      flex:1;
      padding:58px 14px 14px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .tabRow{
      display:flex;
      align-items:center;
      gap:10px;
      justify-content:space-between;
    }
    .tabs{ display:flex; gap:8px; }
    .tab{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      color:#fff;
      opacity:.85;
    }
    .tab.active{ opacity:1; border-color: rgba(255,255,255,.28); }
    .search{ flex:1; display:flex; gap:8px; align-items:center; margin-left:10px; }
    .search input{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.30);
      color:#fff;
      outline:none;
    }

    .grid{
      flex:1;
      overflow:auto;
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px;
      background: rgba(0,0,0,.18);
      display:grid;
      grid-template-columns: repeat(8, minmax(0, 1fr));
      gap:10px;
    }
    .slot{
      height:64px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:6px;
      cursor:pointer;
      position:relative;
      overflow:hidden;
    }
    .slot.locked::after{
      content:"üîí";
      position:absolute;
      font-size:20px;
      opacity:.75;
    }
    .slot .label{
      font-weight:900;
      font-size:12px;
      line-height:1.05;
      text-shadow: 0 1px 2px rgba(0,0,0,.85);
      z-index:2;
    }
    .slot .count{
      position:absolute;
      bottom:4px; right:6px;
      font-size:11px;
      color:#fff;
      opacity:.85;
      z-index:2;
    }
    .slot.selected{ outline:2px solid rgba(255,255,255,.45); }

    /* Inventory modal */
    #invModal .leftPreview{
      width:340px;
      padding:58px 14px 14px 14px;
      border-right:1px solid rgba(255,255,255,.14);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #invModal .rightInv{
      flex:1;
      padding:58px 14px 14px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .invGrid{
      flex:1;
      overflow:auto;
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px;
      background: rgba(0,0,0,.18);
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:10px;
    }
    .item{
      height:74px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      padding:8px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .item .name{ font-weight:900; font-size:12px; }
    .item .qty{ font-size:12px; color:var(--muted); font-weight:900; text-align:right; }

    /* Settings modal */
    #setModal .card{
      width:min(860px, 98vw);
      height:auto;
      max-height:92vh;
      padding:58px 14px 14px 14px;
      display:block;
    }
    .setRow{
      display:flex;
      gap:10px;
      margin:10px 0;
      flex-wrap:wrap;
    }
    .setRow label{
      flex:1;
      min-width:240px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:13px;
      color:var(--muted);
    }
    .setRow input{
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.30);
      color:#fff;
      outline:none;
    }
    .setRow .mini{ font-size:12px; color:var(--muted); line-height:1.3; }

    /* Toast */
    #toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      top:16px;
      background: rgba(0,0,0,.70);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      color:#fff;
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      z-index:60;
      backdrop-filter: blur(6px);
    }
    #toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(0);
    }

    /* Mobile */
    @media (max-width: 900px){
      #buffBar{ min-width: 220px; }
      .grid{ grid-template-columns: repeat(5, minmax(0, 1fr)); }
      .invGrid{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
      #auraModal .leftInfo, #invModal .leftPreview { display:none; }
    }
  </style>
</head>
<body>
  <!-- Background -->
  <div id="bg"></div>
  <div id="biomeColor"></div>
  <div id="whiteOverlay"></div>

  <!-- Glitched FX -->
  <canvas id="glitchNoise"></canvas>
  <div id="glitchScanlines"></div>
  <canvas id="glitchSlices"></canvas>

  <!-- Toast -->
  <div id="toast"></div>

  <!-- Top Bar -->
  <div id="topBar">
    <div class="row">
      <div class="strong" id="playerName">Player (Guest)</div>
      <div class="small">Rolls: <span class="strong" id="rollCountTop">0</span></div>
    </div>
    <div class="row" style="margin-top:6px;">
      <div class="small">Biome: <span class="strong" id="biomeLabel">Normal</span></div>
      <div class="small">Time: <span class="strong" id="biomeTime">‚Äî</span></div>
    </div>
    <div class="row" style="margin-top:8px; gap:8px;">
      <button class="btn" id="loginBtn" style="padding:8px 10px; font-size:13px;">Google Sign-In</button>
      <button class="btn" id="logoutBtn" style="padding:8px 10px; font-size:13px; display:none;">Logout</button>
      <button class="btn bad" id="resetBtn" style="padding:8px 10px; font-size:13px;">Reset Save</button>
    </div>
    <div class="small" style="margin-top:8px; line-height:1.3;">
      Quick Roll unlock: <b>500</b> rolls ‚Ä¢ Auto Roll unlock: <b>1,500</b> rolls<br/>
      Potions: Luck 1/5 sec ‚Ä¢ Speed 1/7 sec ‚Ä¢ Heavenly 1/15 sec (testing)
    </div>
  </div>

  <!-- Left Bar -->
  <div id="leftBar">
    <div class="iconBtn" id="btnAuras" title="Auras">
      ‚ú¶ <div class="tip">Auras</div>
    </div>
    <div class="iconBtn" id="btnInv" title="Inventory">
      üéí <div class="tip">Items</div>
    </div>
    <div class="iconBtn" id="btnSettings" title="Settings">
      ‚öô <div class="tip">Settings</div>
    </div>
  </div>

  <!-- Roll popups lane (Quick Roll ON) -->
  <div id="popupLane"></div>

  <!-- Instant result box (Quick Roll OFF) -->
  <div id="resultBox">
    <div class="big" id="resultName">‚Äî</div>
    <div class="small" id="resultRarity">‚Äî</div>
    <div class="small" id="resultExtra">‚Äî</div>
  </div>

  <!-- Bottom Bar -->
  <div id="bottomBar">
    <div style="width:280px;"></div>

    <div id="rollPanel">
      <div id="rollPanelTop">
        <div class="toggle">
          <span>Auto roll:</span>
          <button id="autoBtn" class="locked">LOCKED</button>
        </div>

        <button id="rollBtn">Roll</button>

        <div class="toggle">
          <span>Quick roll:</span>
          <button id="quickBtn" class="locked">LOCKED</button>
        </div>
      </div>

      <div id="rollPanelBottom">
        <div>Luck: <b id="luckDisplay">x1.00</b></div>
        <div>Roll speed: <b id="speedDisplay">x1.00</b></div>
        <div>Queue: <b id="queueDisplay">0</b></div>
      </div>
    </div>

    <div id="buffBar">
      <div class="buffIcon inactive" id="buffLuck" title="Luck Potion">
        üçÄ <div class="x" id="buffLuckX">x0</div><div class="t" id="buffLuckT">‚Äî</div>
      </div>
      <div class="buffIcon inactive" id="buffSpeed" title="Speed Potion">
        ‚ö° <div class="x" id="buffSpeedX">x0</div><div class="t" id="buffSpeedT">‚Äî</div>
      </div>
      <div class="buffIcon inactive" id="buffHeavenly" title="Heavenly Potion">
        ‚ú® <div class="x" id="buffHeavenlyX">x0</div><div class="t" id="buffHeavenlyT">‚Äî</div>
      </div>
      <div class="buffIcon" id="buffBiome" title="Biome">
        üåç <div class="x" id="buffBiomeX">x1</div><div class="t" id="buffBiomeT">Normal</div>
      </div>
    </div>
  </div>

  <!-- Aura Storage Modal -->
  <div class="modal" id="auraModal">
    <div class="card">
      <div class="modalHeader">Aura Storage</div>
      <button class="close" data-close="auraModal">√ó</button>

      <div class="leftInfo">
        <div class="infoBox">
          <div class="infoTitle" id="auraInfoName">Select an aura</div>
          <div class="infoSub" id="auraInfoSub">Locked auras appear with üîí</div>
          <div class="infoStat" id="auraInfoStats">‚Äî</div>
        </div>

        <div class="infoBox">
          <div class="infoTitle">Actions</div>
          <div class="btnRow">
            <button class="btn good" id="equipBtn">Equip</button>
            <button class="btn bad" id="removeBtn">Remove</button>
          </div>
          <div class="btnRow">
            <button class="btn" id="unlockBtn">Unlock (demo)</button>
          </div>
          <div class="infoSub" style="margin-top:8px;">Demo: Equip sets your name to show equipped aura.</div>
        </div>
      </div>

      <div class="rightGrid">
        <div class="tabRow">
          <div class="tabs">
            <div class="tab active" id="tabRegular">Regular</div>
            <div class="tab" id="tabSpecial">Special</div>
          </div>
          <div class="search">
            <input id="auraSearch" placeholder="Search..." />
          </div>
          <div class="small" id="auraCountLabel">0 / 0</div>
        </div>
        <div class="grid" id="auraGrid"></div>
      </div>
    </div>
  </div>

  <!-- Inventory Modal -->
  <div class="modal" id="invModal">
    <div class="card">
      <div class="modalHeader">Inventory</div>
      <button class="close" data-close="invModal">√ó</button>

      <div class="leftPreview">
        <div class="infoBox">
          <div class="infoTitle" id="invItemName">Select an item</div>
          <div class="infoSub" id="invItemSub">Potions drop automatically every second.</div>
          <div class="infoStat" id="invItemDesc">‚Äî</div>
          <div class="btnRow">
            <button class="btn good" id="useItemBtn" disabled>Use</button>
          </div>
        </div>

        <div class="infoBox">
          <div class="infoTitle">Luck math</div>
          <div class="infoStat" id="luckMathBox">
            Effective odds ‚âà N / LuckMult (clamped to 1).<br/>
            Heavenly overrides Luck potion.
          </div>
        </div>
      </div>

      <div class="rightInv">
        <div class="tabRow">
          <div class="tabs">
            <div class="tab active" id="tabItems">Items</div>
          </div>
          <div class="search">
            <input id="invSearch" placeholder="Search..." />
          </div>
          <div class="small" id="invCountLabel">‚Äî</div>
        </div>
        <div class="invGrid" id="invGrid"></div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="setModal">
    <div class="card">
      <div class="modalHeader">Settings</div>
      <button class="close" data-close="setModal">√ó</button>

      <div class="setRow">
        <label>
          Biome durations (seconds)
          <div class="mini">Glitched does NOT roll after Glitched ends.</div>
        </label>
      </div>

      <div class="setRow">
        <label>Windy duration<input id="durWindy" type="number" min="5" step="1"></label>
        <label>Rainy duration<input id="durRainy" type="number" min="5" step="1"></label>
        <label>Snowy duration<input id="durSnowy" type="number" min="5" step="1"></label>
      </div>
      <div class="setRow">
        <label>Earthquake duration<input id="durQuake" type="number" min="5" step="1"></label>
        <label>Undefined duration<input id="durUndefined" type="number" min="5" step="1"></label>
        <label>Glitched duration<input id="durGlitched" type="number" min="5" step="1"></label>
      </div>

      <div class="setRow">
        <label>
          Reduced Effects
          <div class="mini">Turns off heavy Glitched jitter and slice glitches.</div>
          <button class="btn" id="reducedFxBtn" style="width:220px;">OFF</button>
        </label>

        <label>
          Music
          <div class="mini">
            Put MP3 files next to this HTML (exact names):<br/>
            <b>Normal.mp3</b> <b>Rainy.mp3</b> <b>Snowy.mp3</b> <b>Earthquake.mp3</b> <b>Undefined.mp3</b> <b>Glitched.mp3</b><br/>
            (Windy is optional: <b>Windy.mp3</b>)
          </div>
          <button class="btn" id="musicBtn" style="width:220px;">Music: OFF</button>
        </label>

        <label>
          Save
          <div class="mini">Settings save automatically to localStorage.</div>
          <button class="btn good" id="saveSettingsBtn" style="width:220px;">Apply Settings</button>
        </label>
      </div>
    </div>
  </div>

  <!-- Audio -->
  <audio id="music" preload="auto" crossorigin="anonymous"></audio>

  <script>
    /**********************
     * HELPERS
     **********************/
    function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
    function fmt(n){ return String(n).replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
    function fmtTime(sec){
      sec = Math.max(0, Math.floor(sec));
      const m = Math.floor(sec/60);
      const s = sec%60;
      return m>0 ? `${m}:${String(s).padStart(2,"0")}` : `${s}s`;
    }
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    function toast(msg){
      const t = document.getElementById("toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(toast._to);
      toast._to = setTimeout(()=> t.classList.remove("show"), 1200);
    }
    function num(id, fallback){
      const v = Number(document.getElementById(id).value);
      return Number.isFinite(v) ? v : fallback;
    }
    function getCSS(varName){
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    /**********************
     * 1) DATA DEFINITIONS
     **********************/
    const BIOMES = {
      Normal:     { type:"base",   perSecond:null,  color:getCSS("--c-normal"),    white:0.40 },
      Windy:      { type:"spawn",  perSecond:1/120, color:getCSS("--c-windy"),     white:0.45 },
      Rainy:      { type:"spawn",  perSecond:1/180, color:getCSS("--c-rainy"),     white:0.35 },
      Snowy:      { type:"spawn",  perSecond:1/220, color:getCSS("--c-snowy"),     white:0.58 },
      Earthquake: { type:"spawn",  perSecond:1/420, color:getCSS("--c-quake"),     white:0.30 },
      Undefined:  { type:"spawn",  perSecond:1/999, color:getCSS("--c-undefined"), white:0.24 },
      Glitched:   { type:"special",perSecond:null,  color:getCSS("--c-glitched"),  white:0.18 }
    };

    const DEFAULT_DUR = {
      Windy: 60,
      Rainy: 75,
      Snowy: 70,
      Earthquake: 45,
      Undefined: 30,
      Glitched: 25
    };

    // Aura list (Singularity spelling fixed)
    const AURAS = [
      { name:"Common", base:2 },
      { name:"Uncommon", base:5 },
      { name:"Rare", base:8 },
      { name:"Crystal", base:12 },
      { name:"Rage", base:15 },
      { name:"Diamond", base:30 },
      { name:"Forbidden", base:47 },
      { name:"Atomic", base:63 },
      { name:"Magnetic", base:80 },
      { name:"Glacier", base:150, biome:{ Snowy:45 } },
      { name:"Flower", base:300 },
      { name:"Corrosive", base:550, biome:{ Earthquake:160 } },
      { name:"Devil", base:999 },
      { name:"StarRider", base:1000, biome:{ Windy:350 } },
      { name:"Permafrost", base:2499, biome:{ Snowy:700 } },
      { name:"Aether", base:3000 },
      { name:"Galaxy", base:4555 },
      { name:"Elemental", base:6200 },
      { name:"Speed", base:9999, biome:{ Windy:2500 } },
      { name:"Orchestra", base:10001 },
      { name:"Starlight", base:12500, biome:{ Windy:3000 } },
      { name:"Solar", base:22500 },
      { name:"Lunar", base:22500 },
      { name:"Eclipse", base:30000 },
      { name:"Aquatic", base:44440, biome:{ Rainy:9500 } },
      { name:"Stormy", base:56000, biome:{ Rainy:12500 } },
      { name:"Jade", base:70000 },
      { name:"Copper", base:75000 },
      { name:"Watt", base:80000, biome:{ Windy:18000 } },
      { name:"Honey", base:90000 },
      { name:"Flutterbane", base:100000 },
      { name:"Gemstone", base:175000 },
      { name:"Celestial", base:250000 },
      { name:"Harnessed", base:480000 },
      { name:"Hope", base:500000 },
      { name:"Arcane", base:750000 },
      { name:"Universal", base:1000000 },
      { name:"Worldwide", base:2459010, biome:{ Glitched:999999 } },
      { name:"Origin", base:3000001, biome:{ Glitched:180000 } },
      { name:"Zeus", base:4250000 },
      { name:"Poseidon", base:4250000 },
      { name:"Hades", base:4250000 },
      { name:"Refraction", base:4999999 },
      { name:"Stargazer", base:6410923 },
      { name:"Blizzard", base:10000000, biome:{ Snowy:1000000 } },
      { name:"Universal : Milkyway", base:11111111 },
      { name:"Speed : Of Light", base:12000000, biome:{ Windy:2500000 } },
      { name:"Hades: Overlord", base:16666666 },
      { name:"Flutterbane : Ghost", base:20000001 },
      { name:"Coded", base:21000000 },
      { name:"Terror", base:27500000 },
      { name:"Nihility", base:35000000, biome:{ Glitched:9999999 } },
      { name:"Chromatic", base:45000000 },
      { name:"Raywave", base:66000000, biome:{ Windy:16000000 } },
      { name:"Stormy : Tornado", base:89000000, biome:{ Rainy:17000000 } },
      { name:"Parallax", base:101000000 },
      { name:"Cataclysm", base:125000000, biome:{ Earthquake:88888888 } },
      { name:"Stormy : Cyclone", base:177777777, biome:{ Rainy:65000000 } },
      { name:"Galaxy : Supercluster", base:200000000 },
      { name:"Singularity", base:275000000 },
      { name:"Aftershock", base:375500000, biome:{ Earthquake:99999999 } },
      { name:"Refraction : Prism", base:406541000 },
      { name:"Nebula", base:450000001, biome:{ Undefined:208000001 } },
      { name:"Coded : Overdrive", base:501000000 },
      { name:"Fracture", base:564000000, biome:{ Earthquake:280000000 } },
      { name:"Continuum", base:600000000 },
      { name:"Universal : Collapse", base:725555000 },
      { name:"Nullspace", base:980000000 },
      { name:"Paradox", base:1100000000 },
      { name:"Termination", base:1960010101, biome:{ Undefined:1099999999 } },
      { name:"Absolute Zero", base:3000000000, biome:{ Glitched:1250000000 } }
    ];

    function isSpecialAura(a){
      return a.name.includes(":") || a.base >= 10000000;
    }

    /**********************
     * 2) SAVE / PROFILE
     **********************/
    const SAVE_KEY = "rng_biome_save_fixed_v4";

    const state = {
      user: { mode:"guest", name:"Player (Guest)", uid:"guest" },

      rolls: 0,
      equippedAura: null,

      quickRoll: false,
      autoRoll: false,

      queue: [],
      popupActive: false,

      luckPotionTime: 0,
      speedPotionTime: 0,
      heavenlyPotionTime: 0,

      potions: { luck:0, speed:0, heavenly:0 },

      auraCounts: {},
      auraDiscoveredAt: {},

      biome: "Normal",
      biomeEndsAt: 0,

      settings: {
        durations: { ...DEFAULT_DUR },
        reducedFx: false,
        musicEnabled: false
      }
    };

    function loadSave(){
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return;
      try{
        const data = JSON.parse(raw);
        Object.assign(state, data);

        state.queue ||= [];
        state.auraCounts ||= {};
        state.auraDiscoveredAt ||= {};

        state.settings ||= { durations:{...DEFAULT_DUR}, reducedFx:false, musicEnabled:false };
        state.settings.durations ||= { ...DEFAULT_DUR };

        // ensure duration keys exist
        for(const k of Object.keys(DEFAULT_DUR)){
          if(typeof state.settings.durations[k] !== "number") state.settings.durations[k] = DEFAULT_DUR[k];
        }

        // ensure potion keys exist
        state.potions ||= { luck:0, speed:0, heavenly:0 };
        if(typeof state.potions.luck !== "number") state.potions.luck = 0;
        if(typeof state.potions.speed !== "number") state.potions.speed = 0;
        if(typeof state.potions.heavenly !== "number") state.potions.heavenly = 0;

        state.luckPotionTime = Number(state.luckPotionTime) || 0;
        state.speedPotionTime = Number(state.speedPotionTime) || 0;
        state.heavenlyPotionTime = Number(state.heavenlyPotionTime) || 0;

        if(!BIOMES[state.biome]) state.biome = "Normal";
      }catch(e){
        console.warn("Save load failed", e);
      }
    }

    function save(){
      localStorage.setItem(SAVE_KEY, JSON.stringify({
        user: state.user,
        rolls: state.rolls,
        equippedAura: state.equippedAura,
        quickRoll: state.quickRoll,
        autoRoll: state.autoRoll,
        queue: state.queue,
        popupActive: state.popupActive,
        luckPotionTime: state.luckPotionTime,
        speedPotionTime: state.speedPotionTime,
        heavenlyPotionTime: state.heavenlyPotionTime,
        potions: state.potions,
        auraCounts: state.auraCounts,
        auraDiscoveredAt: state.auraDiscoveredAt,
        biome: state.biome,
        biomeEndsAt: state.biomeEndsAt,
        settings: state.settings
      }));
    }

    function resetSave(){
      localStorage.removeItem(SAVE_KEY);
      location.reload();
    }

    /**********************
     * 3) LUCK / SPEED
     **********************/
    function luckMult(){
      if(state.heavenlyPotionTime > 0) return 1501.0; // +150,000% luck
      if(state.luckPotionTime > 0) return 1.5;        // +50% luck
      return 1.0;
    }

    function speedMult(){
      return state.speedPotionTime > 0 ? 1.15 : 1.0;
    }

    function autoIntervalMs(){
      const base = 900;
      return Math.max(150, Math.floor(base / speedMult()));
    }

    /**********************
     * 4) MUSIC (FIXED)
     * - Uses your actual file names: Normal.mp3, Rainy.mp3, etc.
     * - Glitched: fades out + stops at 1:55
     **********************/
    const musicEl = document.getElementById("music");
   const MUSIC_MAP = {
  Normal: "Normal.mp3",
  Windy: "Windy.mp3",          // optional
  Rainy: "Rainy.mp3",
  Snowy: "Snowy.mp3",
  Earthquake: "Earthquake.mp3",
  Undefined: "Undefined.mp3",
  Glitched: "Glitched.mp3"
};
    };

    let currentMusicBiome = null;
    let fadeTimer = null;
    let glitchedStopTimer = null;

    function clearMusicTimers(){
      if(fadeTimer){ clearInterval(fadeTimer); fadeTimer = null; }
      if(glitchedStopTimer){ clearTimeout(glitchedStopTimer); glitchedStopTimer = null; }
    }

    function fadeTo(targetVol, ms=600){
      clearInterval(fadeTimer);
      const start = Number.isFinite(musicEl.volume) ? musicEl.volume : 1;
      const steps = Math.max(1, Math.floor(ms / 50));
      let i = 0;
      fadeTimer = setInterval(()=>{
        i++;
        const t = i/steps;
        musicEl.volume = start + (targetVol - start) * t;
        if(i >= steps){
          clearInterval(fadeTimer);
          fadeTimer = null;
          musicEl.volume = targetVol;
        }
      }, 50);
    }

    async function stopMusic(){
      clearMusicTimers();
      if(musicEl.currentSrc && !musicEl.paused){
        fadeTo(0, 250);
        await sleep(260);
        musicEl.pause();
      }
    }

    async function playBiomeMusic(biome){
      if(!state.settings.musicEnabled) return;

      const preferred = MUSIC_MAP[biome];
      const fallback = MUSIC_MAP.Normal;

      // if Windy.mp3 isn't present locally, browser will fail it; we fallback to Normal by preloading attempt
      let file = preferred || fallback;

      // If same biome already playing, do nothing
      if(currentMusicBiome === biome && musicEl.currentSrc && !musicEl.paused) return;
      currentMusicBiome = biome;

      clearMusicTimers();

      // fade out old
      if(musicEl.currentSrc && !musicEl.paused){
        fadeTo(0, 220);
        await sleep(230);
        musicEl.pause();
      }

      // load new
      musicEl.loop = biome !== "Glitched";
      musicEl.volume = 0;

      // try preferred, if it errors (Windy missing), fallback to Normal
      const tryPlay = async (src) => {
        musicEl.src = src;
        musicEl.currentTime = 0;
        await musicEl.play();
      };

      try{
        await tryPlay(file);
      }catch(e){
        // fallback if preferred fails (common when Windy.mp3 not present)
        try{
          if(file !== fallback){
            await tryPlay(fallback);
            currentMusicBiome = "Normal";
          }else{
            // autoplay blocked until interaction
            return;
          }
        }catch(e2){
          return;
        }
      }

      fadeTo(0.85, 650);

      // Glitched: stop around 1:55 with a 1s fade out
      if(biome === "Glitched"){
        glitchedStopTimer = setTimeout(async ()=>{
          fadeTo(0, 1000);
          await sleep(1050);
          musicEl.pause();
        }, 115000);
      }
    }

    /**********************
     * 5) BIOME LOGIC
     **********************/
    function biomeDuration(name){
      return state.settings.durations[name] ?? DEFAULT_DUR[name] ?? 30;
    }

    function setBiome(name, durationSec){
      state.biome = name;
      if(name === "Normal"){
        state.biomeEndsAt = 0;
      }else{
        const dur = Math.max(3, durationSec|0);
        state.biomeEndsAt = Date.now() + dur*1000;
      }
      applyBiomeVisuals();
      save();
      uiDirty = true;

      // music switch
      if(state.settings.musicEnabled){
        playBiomeMusic(name);
      }
    }

    function tickBiome(){
      const now = Date.now();

      // If we're in a timed biome and it ended:
      if(state.biome !== "Normal" && state.biomeEndsAt > 0 && now >= state.biomeEndsAt){
        const ended = state.biome;

        // IMPORTANT: Glitched cannot roll after Glitched ends
        if(ended !== "Glitched"){
          const hitGlitched = randInt(1, 2500) === 1;
          if(hitGlitched){
            setBiome("Glitched", biomeDuration("Glitched"));
            toast("Biome changed: Glitched");
            return;
          }
        }

        setBiome("Normal", 0);
        toast(`Biome ended: ${ended}`);
      }
    }

    // Per-second spawn checks
    function tickBiomePerSecond(){
      if(state.biome !== "Normal") return;

      const spawnOrder = ["Windy","Rainy","Snowy","Earthquake","Undefined"];
      for(const b of spawnOrder){
        const p = BIOMES[b].perSecond;
        if(p && Math.random() < p){
          setBiome(b, biomeDuration(b));
          toast(`Biome started: ${b}`);
          break;
        }
      }
    }

    /**********************
     * 6) POTIONS
     * (Optimization: only re-render inventory if modal is open)
     **********************/
    function isModalOpen(id){
      const el = document.getElementById(id);
      return el && el.style.display === "flex";
    }

    function tickPotionDrops(){
      // Every second:
      let got = false;

      if(randInt(1,5) === 1){ state.potions.luck += 1; got = true; toast("+1 Luck Potion"); }
      if(randInt(1,7) === 1){ state.potions.speed += 1; got = true; toast("+1 Speed Potion"); }
      if(randInt(1,15) === 1){ state.potions.heavenly += 1; got = true; toast("+1 Heavenly Potion"); }

      if(got){
        save();
        uiDirty = true;
        if(isModalOpen("invModal")) renderInventory();
      }
    }

    function usePotion(kind){
      if(kind === "luck"){
        if(state.potions.luck <= 0) return;
        state.potions.luck -= 1;
        state.luckPotionTime += 60;
        toast("Used Luck Potion (+50% luck)");

      }else if(kind === "speed"){
        if(state.potions.speed <= 0) return;
        state.potions.speed -= 1;
        state.speedPotionTime += 60;
        toast("Used Speed Potion (+15% roll speed)");

      }else if(kind === "heavenly"){
        if(state.potions.heavenly <= 0) return;
        state.potions.heavenly -= 1;
        state.heavenlyPotionTime += 10;
        toast("Used Heavenly Potion (+150,000% luck)");
      }

      save();
      uiDirty = true;
      if(isModalOpen("invModal")) renderInventory();
    }

    function tickPotionTimers(dtSec){
      const a = state.luckPotionTime > 0;
      const b = state.speedPotionTime > 0;
      const c = state.heavenlyPotionTime > 0;

      if(a) state.luckPotionTime = Math.max(0, state.luckPotionTime - dtSec);
      if(b) state.speedPotionTime = Math.max(0, state.speedPotionTime - dtSec);
      if(c) state.heavenlyPotionTime = Math.max(0, state.heavenlyPotionTime - dtSec);

      if(a || b || c) uiDirty = true;
    }

    /**********************
     * 7) ROLLING / ODDS
     **********************/
    function auraOddsInBiome(aura, biomeName){
      if(aura.biome && aura.biome[biomeName]) return aura.biome[biomeName];
      return aura.base;
    }

    // Luck effect: effective N = floor(N / luckMult), clamped >= 1
    function effectiveN(aura, biomeName){
      const N = auraOddsInBiome(aura, biomeName);
      return Math.max(1, Math.floor(N / luckMult()));
    }

    function rarityText(aura, biomeName){
      const base = aura.base;
      const b = aura.biome?.[biomeName];
      if(b && b !== base){
        return `1 in ${fmt(base)} (Normal) ‚Ä¢ 1 in ${fmt(b)} (${biomeName})`;
      }
      return `1 in ${fmt(base)}`;
    }

    function doRollOnce(){
      const biomeName = state.biome;
      state.rolls += 1;

      // scan from rarest to commonest (higher N first)
      const sorted = [...AURAS].sort((a,b)=> (b.base - a.base));
      let won = sorted[sorted.length-1];

      for(const aura of sorted){
        const N = effectiveN(aura, biomeName);
        if(randInt(1, N) === 1){
          won = aura;
          break;
        }
      }

      const name = won.name;
      state.auraCounts[name] = (state.auraCounts[name] || 0) + 1;

      if(!state.auraDiscoveredAt[name]){
        state.auraDiscoveredAt[name] = {
          rolls: state.rolls,
          biome: biomeName,
          timeISO: new Date().toISOString(),
          luckAtDiscovery: luckMult().toFixed(2)
        };
      }

      save();
      uiDirty = true;
      if(isModalOpen("auraModal")) renderAuraGrid(); // only re-render when open
      return { aura: won, biome: biomeName };
    }

    /**********************
     * 8) QUICK ROLL POPUPS
     **********************/
    function showInstantResult(result){
      const box = document.getElementById("resultBox");
      document.getElementById("resultName").textContent = result.aura.name;
      document.getElementById("resultRarity").textContent = rarityText(result.aura, result.biome);
      document.getElementById("resultExtra").textContent = `Biome: ${result.biome} ‚Ä¢ Rolls: ${fmt(state.rolls)}`;
      box.style.display = "block";
      setTimeout(()=>{ box.style.display = "none"; }, 1200);
    }

    function enqueueResult(result){
      state.queue.push({
        name: result.aura.name,
        rarityLine: rarityText(result.aura, result.biome),
        biome: result.biome,
        time: Date.now()
      });
      save();
      uiDirty = true;

      if(state.quickRoll){
        processQueue();
      }else{
        showInstantResult(result);
      }
    }

    async function processQueue(){
      if(state.popupActive) return;
      state.popupActive = true;

      const lane = document.getElementById("popupLane");
      while(state.quickRoll && state.queue.length > 0){
        const item = state.queue.shift();

        const el = document.createElement("div");
        el.className = "popup";
        el.innerHTML = `
          <div>
            <div class="name">${escapeHtml(item.name)}</div>
            <div class="rar">${escapeHtml(item.rarityLine)}</div>
          </div>
          <div class="right">
            <div>Biome: <b>${escapeHtml(item.biome)}</b></div>
            <div>Rolls: <b>${fmt(state.rolls)}</b></div>
          </div>
        `;
        lane.prepend(el);

        while(lane.children.length > 4){
          lane.removeChild(lane.lastChild);
        }

        if(state.biome === "Glitched" && !state.settings.reducedFx){
          glitchBurst(180);
        }

        uiDirty = true;
        await sleep(420);
      }

      state.popupActive = false;
      save();
      uiDirty = true;
    }

    /**********************
     * 9) AUTO ROLL
     **********************/
    let autoTimer = null;
    let lastAutoInterval = 0;

    function startAutoRoll(){
      stopAutoRoll();
      autoTimer = setInterval(()=>{
        if(!state.autoRoll) return;
        const res = doRollOnce();
        enqueueResult(res);
      }, autoIntervalMs());
      lastAutoInterval = autoIntervalMs();
    }

    function stopAutoRoll(){
      if(autoTimer){
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }

    function maintainAutoTimer(){
      const target = autoIntervalMs();
      if(state.autoRoll && !autoTimer) startAutoRoll();
      if(state.autoRoll && autoTimer && Math.abs(target - lastAutoInterval) > 10){
        startAutoRoll();
      }
      lastAutoInterval = target;
    }

    /**********************
     * 10) GLITCH FX
     **********************/
    const noiseCanvas = document.getElementById("glitchNoise");
    const slicesCanvas = document.getElementById("glitchSlices");
    const scanlinesEl = document.getElementById("glitchScanlines");
    const noiseCtx = noiseCanvas.getContext("2d", { willReadFrequently:true });
    const slicesCtx = slicesCanvas.getContext("2d");

    function resizeFx(){
      const w = window.innerWidth, h = window.innerHeight;
      noiseCanvas.width = w; noiseCanvas.height = h;
      slicesCanvas.width = w; slicesCanvas.height = h;
    }
    window.addEventListener("resize", resizeFx);

    function setGlitchFxEnabled(on){
      noiseCanvas.style.opacity = on ? "0.10" : "0";
      scanlinesEl.style.opacity = on ? "0.08" : "0";
      slicesCanvas.style.opacity = on ? "0.0" : "0";
    }

    // lighter noise (downsample) to reduce lag
    const NOISE_SCALE = 0.35;
    let noiseImg = null;
    let noiseW = 0, noiseH = 0;

    function ensureNoiseBuffer(){
      const w = Math.max(1, Math.floor(noiseCanvas.width * NOISE_SCALE));
      const h = Math.max(1, Math.floor(noiseCanvas.height * NOISE_SCALE));
      if(w === noiseW && h === noiseH && noiseImg) return;
      noiseW = w; noiseH = h;
      noiseImg = noiseCtx.createImageData(w, h);
    }

    function drawNoise(){
      if(state.biome !== "Glitched") return;
      ensureNoiseBuffer();
      const d = noiseImg.data;
      for(let i=0;i<d.length;i+=4){
        const v = (Math.random()*255)|0;
        d[i]=v; d[i+1]=v; d[i+2]=v; d[i+3]=40;
      }
      // draw scaled
      const tmp = document.createElement("canvas");
      tmp.width = noiseW; tmp.height = noiseH;
      const tctx = tmp.getContext("2d");
      tctx.putImageData(noiseImg, 0, 0);
      noiseCtx.clearRect(0,0,noiseCanvas.width,noiseCanvas.height);
      noiseCtx.imageSmoothingEnabled = false;
      noiseCtx.drawImage(tmp, 0, 0, noiseCanvas.width, noiseCanvas.height);
    }

    function glitchBurst(ms=140){
      if(state.settings.reducedFx) return;
      const w = slicesCanvas.width, h = slicesCanvas.height;
      slicesCtx.clearRect(0,0,w,h);

      const slices = randInt(2,6);
      for(let s=0;s<slices;s++){
        const y = randInt(0, Math.max(0,h-40));
        const sh = randInt(10, 40);
        const dx = randInt(-40, 40);

        slicesCtx.fillStyle = "rgba(255,255,255,0.06)";
        slicesCtx.fillRect(0, y, w, sh);

        slicesCtx.fillStyle = "rgba(255,0,0,0.05)";
        slicesCtx.fillRect(Math.max(0,dx), y, w, sh);
        slicesCtx.fillStyle = "rgba(0,255,255,0.05)";
        slicesCtx.fillRect(Math.max(0,-dx), y, w, sh);
      }
      slicesCanvas.style.opacity = "0.65";
      setTimeout(()=>{
        slicesCanvas.style.opacity = "0.0";
        slicesCtx.clearRect(0,0,w,h);
      }, ms);
    }

    let nextJitterAt = 0;
    function tickJitter(){
      if(state.biome !== "Glitched") {
        document.body.style.transform = "";
        return;
      }
      if(state.settings.reducedFx) return;
      const now = Date.now();
      if(now < nextJitterAt) return;

      nextJitterAt = now + randInt(4000, 9000);
      const dx = randInt(-6,6);
      const dy = randInt(-5,5);
      const rot = (Math.random()*1.2 - 0.6).toFixed(3);
      document.body.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
      setTimeout(()=>{ document.body.style.transform = ""; }, randInt(80, 160));
    }

    /**********************
     * 11) BIOME VISUALS
     **********************/
    function applyBiomeVisuals(){
      const b = state.biome;
      const bc = document.getElementById("biomeColor");
      const wo = document.getElementById("whiteOverlay");

      bc.style.backgroundColor = BIOMES[b].color;

      if(b === "Snowy"){
        bc.style.opacity = "0.02";
        wo.style.opacity = String(BIOMES[b].white);
      }else{
        bc.style.opacity = (b === "Undefined" ? "0.62" : "0.55");
        wo.style.opacity = String(BIOMES[b].white);
      }

      if(b === "Glitched"){
        setGlitchFxEnabled(true);
      }else{
        setGlitchFxEnabled(false);
        slicesCanvas.style.opacity = "0";
        document.body.style.transform = "";
      }

      document.getElementById("buffBiomeT").textContent = b;
      uiDirty = true;
    }

    /**********************
     * 12) UI RENDERING (THROTTLED)
     **********************/
    let uiDirty = true;

    function updateUI(){
      // name
      document.getElementById("playerName").textContent =
        state.equippedAura ? `${state.user.name} ‚Ä¢ ${state.equippedAura}` : state.user.name;

      document.getElementById("rollCountTop").textContent = fmt(state.rolls);
      document.getElementById("biomeLabel").textContent = state.biome;

      // biome time left
      if(state.biome === "Normal" || !state.biomeEndsAt){
        document.getElementById("biomeTime").textContent = "‚Äî";
      }else{
        const left = Math.max(0, Math.ceil((state.biomeEndsAt - Date.now())/1000));
        document.getElementById("biomeTime").textContent = left + "s";
      }

      // unlock logic
      const quickUnlocked = state.rolls >= 500;
      const autoUnlocked = state.rolls >= 1500;

      const quickBtn = document.getElementById("quickBtn");
      quickBtn.classList.toggle("locked", !quickUnlocked);
      quickBtn.textContent = !quickUnlocked ? "LOCKED" : (state.quickRoll ? "ON" : "OFF");

      const autoBtn = document.getElementById("autoBtn");
      autoBtn.classList.toggle("locked", !autoUnlocked);
      autoBtn.textContent = !autoUnlocked ? "LOCKED" : (state.autoRoll ? "ON" : "OFF");

      document.getElementById("luckDisplay").textContent = "x" + luckMult().toFixed(2);
      document.getElementById("speedDisplay").textContent = "x" + speedMult().toFixed(2);
      document.getElementById("queueDisplay").textContent = String(state.queue.length);

      // Buff icons
      const luckIcon = document.getElementById("buffLuck");
      const speedIcon = document.getElementById("buffSpeed");
      const heavenlyIcon = document.getElementById("buffHeavenly");

      document.getElementById("buffLuckX").textContent = "x" + state.potions.luck;
      document.getElementById("buffSpeedX").textContent = "x" + state.potions.speed;
      document.getElementById("buffHeavenlyX").textContent = "x" + state.potions.heavenly;

      if(state.luckPotionTime > 0){
        luckIcon.classList.remove("inactive");
        document.getElementById("buffLuckT").textContent = fmtTime(state.luckPotionTime);
      }else{
        luckIcon.classList.toggle("inactive", state.potions.luck <= 0);
        document.getElementById("buffLuckT").textContent = "‚Äî";
      }

      if(state.speedPotionTime > 0){
        speedIcon.classList.remove("inactive");
        document.getElementById("buffSpeedT").textContent = fmtTime(state.speedPotionTime);
      }else{
        speedIcon.classList.toggle("inactive", state.potions.speed <= 0);
        document.getElementById("buffSpeedT").textContent = "‚Äî";
      }

      if(state.heavenlyPotionTime > 0){
        heavenlyIcon.classList.remove("inactive");
        document.getElementById("buffHeavenlyT").textContent = fmtTime(state.heavenlyPotionTime);
      }else{
        heavenlyIcon.classList.toggle("inactive", state.potions.heavenly <= 0);
        document.getElementById("buffHeavenlyT").textContent = "‚Äî";
      }

      document.getElementById("buffBiomeX").textContent = "x1";

      // settings UI (only write if modal open to avoid constant DOM writes)
      if(isModalOpen("setModal")){
        document.getElementById("durWindy").value = state.settings.durations.Windy;
        document.getElementById("durRainy").value = state.settings.durations.Rainy;
        document.getElementById("durSnowy").value = state.settings.durations.Snowy;
        document.getElementById("durQuake").value = state.settings.durations.Earthquake;
        document.getElementById("durUndefined").value = state.settings.durations.Undefined;
        document.getElementById("durGlitched").value = state.settings.durations.Glitched;
      }

      document.getElementById("reducedFxBtn").textContent = state.settings.reducedFx ? "ON" : "OFF";
      document.getElementById("musicBtn").textContent = "Music: " + (state.settings.musicEnabled ? "ON" : "OFF");

      const isGuest = state.user.mode === "guest";
      document.getElementById("loginBtn").style.display = isGuest ? "block" : "none";
      document.getElementById("logoutBtn").style.display = isGuest ? "none" : "block";
    }

    function renderAuraGrid(){
      const grid = document.getElementById("auraGrid");
      const q = (document.getElementById("auraSearch").value || "").toLowerCase().trim();
      const showSpecial = document.getElementById("tabSpecial").classList.contains("active");

      const list = AURAS
        .filter(a => showSpecial ? isSpecialAura(a) : !isSpecialAura(a))
        .filter(a => !q || a.name.toLowerCase().includes(q));

      grid.innerHTML = "";

      for(const aura of list){
        const discovered = !!state.auraCounts[aura.name];
        const slot = document.createElement("div");
        slot.className = "slot" + (discovered ? "" : " locked");
        slot.dataset.name = aura.name;

        const count = state.auraCounts[aura.name] || 0;

        const label = document.createElement("div");
        label.className = "label";
        label.textContent = discovered ? aura.name : "";
        slot.appendChild(label);

        if(discovered){
          const c = document.createElement("div");
          c.className = "count";
          c.textContent = "x" + count;
          slot.appendChild(c);
        }

        slot.addEventListener("click", ()=> selectAura(aura.name));
        grid.appendChild(slot);
      }

      const discoveredCount = Object.keys(state.auraCounts).length;
      document.getElementById("auraCountLabel").textContent = `${discoveredCount} / ${AURAS.length}`;
    }

    let selectedAuraName = null;
    function selectAura(name){
      selectedAuraName = name;
      document.querySelectorAll(".slot").forEach(s=> s.classList.toggle("selected", s.dataset.name === name));

      const aura = AURAS.find(a=>a.name===name);
      const discovered = !!state.auraCounts[name];

      document.getElementById("auraInfoName").textContent = discovered ? name : "(Locked)";
      document.getElementById("auraInfoSub").textContent = discovered ? "Information" : "This aura is locked (not discovered).";

      if(discovered){
        const meta = state.auraDiscoveredAt[name];
        const lines = [];
        lines.push(`Rarity: 1 in ${fmt(aura.base)}`);
        if(aura.biome){
          for(const [b, n] of Object.entries(aura.biome)){
            lines.push(`Native in ${b}: 1 in ${fmt(n)}`);
          }
        }
        if(meta){
          lines.push(`Rolled at: ${fmt(meta.rolls)} rolls`);
          lines.push(`Luck at discovery: x${meta.luckAtDiscovery}`);
          lines.push(`Biome discovered: ${meta.biome}`);
          lines.push(`Time discovered: ${new Date(meta.timeISO).toLocaleString()}`);
        }
        document.getElementById("auraInfoStats").innerHTML = lines.map(escapeHtml).join("<br/>");
      }else{
        document.getElementById("auraInfoStats").textContent = `Rarity: 1 in ${fmt(aura.base)}`;
      }
    }

    function renderInventory(){
      const grid = document.getElementById("invGrid");
      const q = (document.getElementById("invSearch").value || "").toLowerCase().trim();

      const items = [
        { key:"luck", name:"Luck Potion", desc:"Gives you 1 minute of [Lucky]\n[Lucky]: +50% luck", qty: state.potions.luck },
        { key:"speed", name:"Speed Potion", desc:"Gives you 1 minute of [Speed]\n[Speed]: +15% roll speed", qty: state.potions.speed },
        { key:"heavenly", name:"Heavenly Potion", desc:"Gives you 10 seconds of [Heavenly]\n[Heavenly]: +150,000% luck", qty: state.potions.heavenly }
      ].filter(i => !q || i.name.toLowerCase().includes(q));

      grid.innerHTML = "";
      for(const it of items){
        const el = document.createElement("div");
        el.className = "item";
        el.innerHTML = `<div class="name">${escapeHtml(it.name)}</div><div class="qty">x${it.qty}</div>`;
        el.addEventListener("click", ()=> selectItem(it));
        grid.appendChild(el);
      }
      document.getElementById("invCountLabel").textContent = `${items.length} item types`;
    }

    let selectedItemKey = null;
    function selectItem(item){
      selectedItemKey = item.key;
      document.getElementById("invItemName").textContent = item.name;
      document.getElementById("invItemDesc").textContent = item.desc;
      document.getElementById("useItemBtn").disabled = !(item.qty > 0);
    }

    /**********************
     * 13) MODALS / EVENTS
     **********************/
    function openModal(id){
      document.getElementById(id).style.display = "flex";
      if(id === "auraModal") renderAuraGrid();
      if(id === "invModal") renderInventory();
      uiDirty = true;
    }
    function closeModal(id){
      document.getElementById(id).style.display = "none";
      uiDirty = true;
    }

    document.querySelectorAll("[data-close]").forEach(btn=>{
      btn.addEventListener("click", ()=> closeModal(btn.dataset.close));
    });

    document.getElementById("btnAuras").addEventListener("click", ()=> openModal("auraModal"));
    document.getElementById("btnInv").addEventListener("click", ()=> openModal("invModal"));
    document.getElementById("btnSettings").addEventListener("click", ()=> openModal("setModal"));

    document.getElementById("auraSearch").addEventListener("input", renderAuraGrid);
    document.getElementById("invSearch").addEventListener("input", renderInventory);

    // Tabs
    document.getElementById("tabRegular").addEventListener("click", ()=>{
      document.getElementById("tabRegular").classList.add("active");
      document.getElementById("tabSpecial").classList.remove("active");
      renderAuraGrid();
    });
    document.getElementById("tabSpecial").addEventListener("click", ()=>{
      document.getElementById("tabSpecial").classList.add("active");
      document.getElementById("tabRegular").classList.remove("active");
      renderAuraGrid();
    });

    // Aura actions
    document.getElementById("equipBtn").addEventListener("click", ()=>{
      if(!selectedAuraName) return;
      if(!state.auraCounts[selectedAuraName]) return toast("You haven't discovered that aura yet.");
      state.equippedAura = selectedAuraName;
      toast("Equipped: " + selectedAuraName);
      save(); uiDirty = true;
    });
    document.getElementById("removeBtn").addEventListener("click", ()=>{
      state.equippedAura = null;
      toast("Removed equipped aura");
      save(); uiDirty = true;
    });
    document.getElementById("unlockBtn").addEventListener("click", ()=>{
      if(!selectedAuraName) return;
      if(state.auraCounts[selectedAuraName]) return toast("Already discovered.");
      state.auraCounts[selectedAuraName] = 1;
      state.auraDiscoveredAt[selectedAuraName] = {
        rolls: state.rolls,
        biome: state.biome,
        timeISO: new Date().toISOString(),
        luckAtDiscovery: luckMult().toFixed(2)
      };
      toast("Unlocked (demo): " + selectedAuraName);
      save();
      renderAuraGrid();
      selectAura(selectedAuraName);
      uiDirty = true;
    });

    // Inventory use
    document.getElementById("useItemBtn").addEventListener("click", ()=>{
      if(!selectedItemKey) return;
      usePotion(selectedItemKey);
      if(isModalOpen("invModal")) renderInventory();
    });

    // Buff bar click shortcuts
    document.getElementById("buffLuck").addEventListener("click", ()=>{
      if(state.potions.luck > 0) usePotion("luck");
    });
    document.getElementById("buffSpeed").addEventListener("click", ()=>{
      if(state.potions.speed > 0) usePotion("speed");
    });
    document.getElementById("buffHeavenly").addEventListener("click", ()=>{
      if(state.potions.heavenly > 0) usePotion("heavenly");
    });

    // Roll cooldown (reduces lag / spam)
    let rollLocked = false;

    // Roll button (also unlocks browser audio)
    document.getElementById("rollBtn").addEventListener("click", async ()=>{
      if(rollLocked) return;
      rollLocked = true;
      setTimeout(()=>{ rollLocked = false; }, 80);

      const res = doRollOnce();
      enqueueResult(res);

      // tiny glitched burst on roll
      if(state.biome === "Glitched") glitchBurst(160);

      // if music enabled, ensure it starts after interaction
      if(state.settings.musicEnabled){
        await playBiomeMusic(state.biome);
      }
    });

    // Quick toggle
    document.getElementById("quickBtn").addEventListener("click", ()=>{
      if(state.rolls < 500) return toast("Quick Roll unlocks at 500 rolls.");
      state.quickRoll = !state.quickRoll;
      toast("Quick Roll: " + (state.quickRoll ? "ON" : "OFF"));
      save();
      uiDirty = true;
      if(state.quickRoll) processQueue();
    });

    // Auto toggle
    document.getElementById("autoBtn").addEventListener("click", ()=>{
      if(state.rolls < 1500) return toast("Auto Roll unlocks at 1,500 rolls.");
      state.autoRoll = !state.autoRoll;
      toast("Auto Roll: " + (state.autoRoll ? "ON" : "OFF"));
      save();
      uiDirty = true;
      if(state.autoRoll) startAutoRoll(); else stopAutoRoll();
    });

    // Settings
    document.getElementById("reducedFxBtn").addEventListener("click", ()=>{
      state.settings.reducedFx = !state.settings.reducedFx;
      toast("Reduced Effects: " + (state.settings.reducedFx ? "ON" : "OFF"));
      save(); uiDirty = true;
    });

    document.getElementById("musicBtn").addEventListener("click", async ()=>{
      state.settings.musicEnabled = !state.settings.musicEnabled;
      toast("Music: " + (state.settings.musicEnabled ? "ON" : "OFF"));
      save(); uiDirty = true;

      if(state.settings.musicEnabled){
        await playBiomeMusic(state.biome);
      }else{
        await stopMusic();
      }
    });

    document.getElementById("saveSettingsBtn").addEventListener("click", ()=>{
      const d = state.settings.durations;
      d.Windy = num("durWindy", d.Windy);
      d.Rainy = num("durRainy", d.Rainy);
      d.Snowy = num("durSnowy", d.Snowy);
      d.Earthquake = num("durQuake", d.Earthquake);
      d.Undefined = num("durUndefined", d.Undefined);
      d.Glitched = num("durGlitched", d.Glitched);

      toast("Settings applied");
      save();
      uiDirty = true;
    });

    // Reset save
    document.getElementById("resetBtn").addEventListener("click", ()=>{
      if(confirm("Reset ALL saved data?")) resetSave();
    });

    // Google Sign-In (stub)
    document.getElementById("loginBtn").addEventListener("click", async ()=>{
      toast("Firebase not configured in this prototype. Running as Guest.");
    });
    document.getElementById("logoutBtn").addEventListener("click", async ()=>{
      state.user = { mode:"guest", name:"Player (Guest)", uid:"guest" };
      toast("Logged out (Guest mode)");
      save(); uiDirty = true;
    });

    // Close modals by clicking outside card
    document.querySelectorAll(".modal").forEach(m=>{
      m.addEventListener("click",(e)=>{
        if(e.target === m) m.style.display="none";
      });
    });

    /**********************
     * 14) GAME LOOP (OPTIMIZED)
     * - Per-second logic uses a 1s interval (biome spawns + potion drops)
     * - Timers use a 60fps raf but UI updates are throttled
     **********************/
    let lastFrame = performance.now();

    function frame(now){
      const dt = Math.min(0.25, (now - lastFrame)/1000);
      lastFrame = now;

      tickPotionTimers(dt);
      tickBiome();
      maintainAutoTimer();

      if(state.biome === "Glitched"){
        drawNoise();
        tickJitter();
        if(!state.settings.reducedFx && Math.random() < 0.004){
          glitchBurst(randInt(80, 140));
        }
      }

      requestAnimationFrame(frame);
    }

    // Per-second tick
    setInterval(()=>{
      // only do spawn + potion drop once per second
      tickBiomePerSecond();
      tickPotionDrops();
    }, 1000);

    // UI tick (5 fps)
    setInterval(()=>{
      if(!uiDirty) return;
      uiDirty = false;
      updateUI();
    }, 200);

    /**********************
     * 15) INIT
     **********************/
    function init(){
      loadSave();
      resizeFx();

      if(!BIOMES[state.biome]) state.biome = "Normal";
      applyBiomeVisuals();

      if(state.autoRoll) startAutoRoll();

      updateUI();
      renderAuraGrid();
      renderInventory();

      requestAnimationFrame(frame);
    }

    init();
  </script>
</body>
</html>
